import{_ as i,c as l,o as e,aj as r}from"./chunks/framework.BZD6ashX.js";const u=JSON.parse('{"title":"☕ JVM 核心知识","description":"","frontmatter":{},"headers":[],"relativePath":"JVM.md","filePath":"JVM.md"}'),t={name:"JVM.md"};function o(n,a,s,d,c,g){return e(),l("div",null,[...a[0]||(a[0]=[r('<h1 id="☕-jvm-核心知识" tabindex="-1">☕ JVM 核心知识 <a class="header-anchor" href="#☕-jvm-核心知识" aria-label="Permalink to “☕ JVM 核心知识”">​</a></h1><hr><h1 id="i-内存模型-runtime-data-areas" tabindex="-1">I. 内存模型 (Runtime Data Areas) <a class="header-anchor" href="#i-内存模型-runtime-data-areas" aria-label="Permalink to “I. 内存模型 (Runtime Data Areas)”">​</a></h1><h3 id="_1-区域划分" tabindex="-1">1. 区域划分 <a class="header-anchor" href="#_1-区域划分" aria-label="Permalink to “1. 区域划分”">​</a></h3><p>JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域：</p><ul><li><p><strong>线程私有</strong>：</p><ul><li><strong>程序计数器 (Program Counter Register)</strong>：当前线程所执行的字节码的行号指示器，是唯一一个不会出现 OOM 的区域.</li><li><strong>虚拟机栈 (VM Stack)</strong>：描述 Java 方法执行的内存模型，每个方法执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息.</li><li><strong>本地方法栈 (Native Method Stack)</strong>：与虚拟机栈类似，不过是为 Native 方法服务.</li></ul></li><li><p><strong>线程共享</strong>：</p><ul><li><strong>堆 (Heap)</strong>：JVM 管理的最大一块内存，存放对象实例，是 GC 的主要区域.</li><li><strong>方法区 (Method Area)</strong>：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 (JDK 8 后由元空间 Metaspace 实现，使用本地内存).</li></ul></li></ul><h3 id="_2-堆内存分布" tabindex="-1">2. 堆内存分布 <a class="header-anchor" href="#_2-堆内存分布" aria-label="Permalink to “2. 堆内存分布”">​</a></h3><ul><li><strong>新生代 (Young Generation)</strong>： <ul><li><strong>Eden 区</strong>：新对象主要分配在 Eden 区.</li><li><strong>Survivor 区 (S0, S1)</strong>：存活对象在 S0/S1 之间复制，默认比例 Eden:S0:S1 = 8:1:1.</li></ul></li><li><strong>老年代 (Old Generation)</strong>：存放生命周期较长的对象.</li></ul><hr><h1 id="ii-垃圾回收-gc" tabindex="-1">II. 垃圾回收 (GC) <a class="header-anchor" href="#ii-垃圾回收-gc" aria-label="Permalink to “II. 垃圾回收 (GC)”">​</a></h1><h3 id="_1-如何判断对象已死" tabindex="-1">1. 如何判断对象已死？ <a class="header-anchor" href="#_1-如何判断对象已死" aria-label="Permalink to “1. 如何判断对象已死？”">​</a></h3><ul><li><strong>引用计数法</strong>：对象被引用一次加1，引用失效减1。无法解决循环引用问题.</li><li><strong>可达性分析算法</strong> (主流)：从 GC Roots (如栈中引用的对象、静态变量引用的对象) 出发，通过引用链向下搜索，不可达的对象即可回收.</li></ul><h3 id="_2-常见的-gc-算法" tabindex="-1">2. 常见的 GC 算法 <a class="header-anchor" href="#_2-常见的-gc-算法" aria-label="Permalink to “2. 常见的 GC 算法”">​</a></h3><ul><li><strong>标记-清除 (Mark-Sweep)</strong>：标记出所有需要回收的对象，统一回收。缺点：内存碎片.</li><li><strong>标记-复制 (Mark-Copy)</strong>：将内存分为两块，每次只用一块，将存活对象复制到另一块。优点：无碎片；缺点：内存利用率低 (用于新生代).</li><li><strong>标记-整理 (Mark-Compact)</strong>：标记存活对象，将其向一端移动，清理掉边界以外的内存。优点：无碎片 (用于老年代).</li></ul><h3 id="_3-说明一下-cms-和-g1" tabindex="-1">3. 说明一下 CMS 和 G1 <a class="header-anchor" href="#_3-说明一下-cms-和-g1" aria-label="Permalink to “3. 说明一下 CMS 和 G1”">​</a></h3><ul><li><p><strong>CMS (Concurrent Mark Sweep)</strong>：</p><ul><li>以获取<strong>最短回收停顿时间</strong>为目标.</li><li>基于“标记-清除”算法.</li><li>过程：初始标记(STW) -&gt; 并发标记 -&gt; 重新标记(STW) -&gt; 并发清除.</li><li>缺点：对 CPU 敏感、产生内存碎片.</li></ul></li><li><p><strong>G1 (Garbage First)</strong>：</p><ul><li>面向服务端应用，<strong>可预测停顿</strong>.</li><li>将堆划分为多个大小相等的 Region.</li><li>整体看是“标记-整理”，局部看是“标记-复制”，不会产生内存碎片.</li><li>适合大内存机器，JDK 9 默认收集器.</li></ul></li></ul><hr><h1 id="iii-类加载机制" tabindex="-1">III. 类加载机制 <a class="header-anchor" href="#iii-类加载机制" aria-label="Permalink to “III. 类加载机制”">​</a></h1><h3 id="_1-类加载过程" tabindex="-1">1. 类加载过程 <a class="header-anchor" href="#_1-类加载过程" aria-label="Permalink to “1. 类加载过程”">​</a></h3><ol><li><strong>加载 (Loading)</strong>：通过全类名获取二进制字节流，将静态存储结构转化为方法区的运行时数据结构.</li><li><strong>链接 (Linking)</strong>： <ul><li><strong>验证</strong>：确保字节码符合规范.</li><li><strong>准备</strong>：为静态变量分配内存并设置零值.</li><li><strong>解析</strong>：将常量池内的符号引用替换为直接引用.</li></ul></li><li><strong>初始化 (Initialization)</strong>：执行类构造器 <code>&lt;clinit&gt;</code> 方法 (静态代码块赋值).</li></ol><h3 id="_2-双亲委派模型-dual-parent-delegation" tabindex="-1">2. 双亲委派模型 (Dual Parent Delegation) <a class="header-anchor" href="#_2-双亲委派模型-dual-parent-delegation" aria-label="Permalink to “2. 双亲委派模型 (Dual Parent Delegation)”">​</a></h3><ul><li><strong>定义</strong>：当一个类加载器收到类加载请求时，首先委托给父类加载器去完成，父加载器无法加载时才自己尝试加载.</li><li><strong>好处</strong>：保证核心类库 (如 <code>java.lang.Object</code>) 的安全性，避免用户自定义类覆盖核心类.</li><li><strong>打破场景</strong>：JDBC (通过 SPI 机制)、Tomcat (Web 应用隔离).</li></ul><hr><h1 id="iv-常见-jvm-参数与排查" tabindex="-1">IV. 常见 JVM 参数与排查 <a class="header-anchor" href="#iv-常见-jvm-参数与排查" aria-label="Permalink to “IV. 常见 JVM 参数与排查”">​</a></h1><h3 id="_1-常用参数" tabindex="-1">1. 常用参数 <a class="header-anchor" href="#_1-常用参数" aria-label="Permalink to “1. 常用参数”">​</a></h3><ul><li><code>-Xms</code> / <code>-Xmx</code>：设置堆的初始大小和最大大小 (通常设置为相同，避免动态扩容抖动).</li><li><code>-Xmn</code>：设置新生代大小.</li><li><code>-XX:MetaspaceSize</code>：设置元空间初始大小.</li><li><code>-XX:+PrintGCDetails</code>：打印 GC 详细日志.</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：OOM 时自动 Dump 堆内存.</li></ul><h3 id="_2-线上排查工具" tabindex="-1">2. 线上排查工具 <a class="header-anchor" href="#_2-线上排查工具" aria-label="Permalink to “2. 线上排查工具”">​</a></h3><ul><li><code>jps</code>：查看 Java 进程状态.</li><li><code>jstat</code>：监视虚拟机各种运行状态信息 (GC 情况等).</li><li><code>jinfo</code>：实时查看和调整虚拟机各项参数.</li><li><code>jmap</code>：生成堆转储快照 (dump 文件).</li><li><code>jstack</code>：生成虚拟机当前时刻的线程快照 (排查死锁、CPU 飙高).</li><li><strong>Arthas</strong>：阿里开源的 Java 诊断工具 (推荐).</li></ul>',28)])])}const m=i(t,[["render",o]]);export{u as __pageData,m as default};
