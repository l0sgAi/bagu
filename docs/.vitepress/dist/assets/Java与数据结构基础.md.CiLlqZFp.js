import{_ as l,c as i,o,aj as t}from"./chunks/framework.BZD6ashX.js";const u=JSON.parse('{"title":"⚒️JDK源码分析与数据结构基础","description":"","frontmatter":{},"headers":[],"relativePath":"Java与数据结构基础.md","filePath":"Java与数据结构基础.md"}'),a={name:"Java与数据结构基础.md"};function n(s,r,e,g,p,h){return o(),i("div",null,[...r[0]||(r[0]=[t('<h1 id="⚒️jdk源码分析与数据结构基础" tabindex="-1">⚒️JDK源码分析与数据结构基础 <a class="header-anchor" href="#⚒️jdk源码分析与数据结构基础" aria-label="Permalink to “⚒️JDK源码分析与数据结构基础”">​</a></h1><h2 id="jdk源码分析" tabindex="-1">JDK源码分析 <a class="header-anchor" href="#jdk源码分析" aria-label="Permalink to “JDK源码分析”">​</a></h2><h3 id="i-hashmap-与-concurrenthashmap-的底层实现" tabindex="-1">I. HashMap 与 ConcurrentHashMap 的底层实现 <a class="header-anchor" href="#i-hashmap-与-concurrenthashmap-的底层实现" aria-label="Permalink to “I. HashMap 与 ConcurrentHashMap 的底层实现”">​</a></h3><p>这是重灾区，一定要分 JDK 1.7 和 1.8 两个版本回答，体现深度。</p><h4 id="hashmap" tabindex="-1"><strong>HashMap</strong> <a class="header-anchor" href="#hashmap" aria-label="Permalink to “HashMap”">​</a></h4><ul><li><p><strong>底层结构：</strong></p><ul><li><p><strong>JDK 1.7：</strong> 数组 + 链表。</p></li><li><p><strong>JDK 1.8：</strong> 数组 + 链表 + <strong>红黑树</strong>。</p><ul><li>转换条件： 当链表长度大于 8 <strong>且</strong> 数组长度大于 64 时，链表转为红黑树（查找从 <code>O(n)</code> 优化为<code> O(logn)</code>）；当节点少于 6 时退化为链表。</li></ul></li></ul></li><li><p><strong>扩容机制：</strong></p><ul><li><p>默认初始容量 16，加载因子 0.75。</p></li><li><p>当元素个数 &gt; 容量 * 加载因子时，扩容为原来的 <strong>2倍</strong>。</p></li></ul></li><li><p><strong>线程安全性：</strong> 不安全。多线程下扩容可能导致死循环（1.7）或数据覆盖（1.8）。</p></li></ul><h4 id="concurrenthashmap-chm" tabindex="-1"><strong>ConcurrentHashMap (CHM)</strong> <a class="header-anchor" href="#concurrenthashmap-chm" aria-label="Permalink to “ConcurrentHashMap (CHM)”">​</a></h4><ul><li><p><strong>JDK 1.7（分段锁）：</strong></p><ul><li><p><strong>结构：</strong> Segment 数组 + HashEntry 数组。</p></li><li><p><strong>锁机制：</strong> Segment 继承自 ReentrantLock。将数据分成一段一段存储，给每一段数据配一把锁。</p></li><li><p><strong>并发度：</strong> 默认 16（即支持 16 个线程并发写）。</p></li></ul></li><li><p><strong>JDK 1.8（CAS + synchronized）：</strong></p><ul><li><p><strong>结构：</strong> 与 HashMap 1.8 一致（数组 + 链表 + 红黑树）。</p></li><li><p><strong>锁机制：</strong> 抛弃了分段锁。使用 <strong>CAS</strong> 添加新节点，使用 <strong>synchronized</strong> 锁定链表或树的<strong>首节点</strong>。</p></li><li><p><strong>优势：</strong> 锁粒度更细（只锁当前桶），并发性能更高。</p></li></ul></li></ul><hr><h3 id="ii-arraylist-的底层实现" tabindex="-1">II. ArrayList 的底层实现 <a class="header-anchor" href="#ii-arraylist-的底层实现" aria-label="Permalink to “II. ArrayList 的底层实现”">​</a></h3><ul><li><p><strong>底层数据结构：</strong> 动态数组（Object[] elementData）。</p></li><li><p><strong>初始容量：</strong> 默认为 10（注意：JDK 1.8+ 是懒加载，第一次 add 时才初始化数组）。</p></li><li><p><strong>扩容机制：</strong></p><ul><li><p>当容量不足时，扩容为原来的 <strong>1.5 倍</strong>（oldCapacity + (oldCapacity &gt;&gt; 1)）。</p></li><li><p>扩容本质是 System.arraycopy，将老数组元素复制到新数组，比较耗时。</p></li></ul></li><li><p><strong>特点：</strong></p><ul><li><p>支持随机访问（根据下标查询），时间复杂度 O(1)</p><p>。</p></li><li><p>插入/删除效率低（因为要移动后续元素），时间复杂度 O(n)</p><p>。</p></li></ul></li><li><p><strong>线程安全：</strong> 不安全。并发场景建议使用 CopyOnWriteArrayList。</p></li></ul><hr><h3 id="iii-哈希冲突-hash-collision-怎么解决" tabindex="-1">III. 哈希冲突（Hash Collision）怎么解决？ <a class="header-anchor" href="#iii-哈希冲突-hash-collision-怎么解决" aria-label="Permalink to “III. 哈希冲突（Hash Collision）怎么解决？”">​</a></h3><p>面试官通常想听前两种，特别是第一种。</p><ol><li><p><strong>链地址法（拉链法 - Chaining）：</strong></p><ul><li><p><strong>原理：</strong> 数组的每个槽位指向一个链表，所有哈希值相同的元素都存在链表中。</p></li><li><p><strong>应用：</strong> <strong>Java 的 HashMap</strong> 就是用的这种（1.8 后链表过长转红黑树）。</p></li></ul></li><li><p><strong>开放寻址法（Open Addressing）：</strong></p><ul><li><p><strong>原理：</strong> 发生冲突时，去寻找下一个空的槽位。常见方式有线性探测（+1, +2...）或二次探测。</p></li><li><p><strong>应用：</strong> Java 的 <strong>ThreadLocalMap</strong>。</p></li></ul></li><li><p><strong>再哈希法（Re-Hashing）：</strong></p><ul><li>准备多个哈希函数，第一个冲突了就用第二个，直到不冲突为止。</li></ul></li><li><p><strong>公共溢出区法：</strong></p><ul><li>建立一个公共的溢出区（通常也是数组），凡是冲突的元素都扔进去。</li></ul></li></ol><hr><h3 id="iv-其它" tabindex="-1">IV. 其它 <a class="header-anchor" href="#iv-其它" aria-label="Permalink to “IV. 其它”">​</a></h3><h4 id="_1-string、stringbuffer、stringbuilder-的区别" tabindex="-1">1. String、StringBuffer、StringBuilder 的区别？ <a class="header-anchor" href="#_1-string、stringbuffer、stringbuilder-的区别" aria-label="Permalink to “1. String、StringBuffer、StringBuilder 的区别？”">​</a></h4><ul><li><p><strong>String：</strong> <strong>不可变</strong>字符序列（底层是 final char[]，JDK9改为 byte[]）。每次修改都会创建新对象，适合少量操作。</p></li><li><p><strong>StringBuilder：</strong> <strong>可变</strong>字符序列。<strong>线程不安全</strong>，效率最高。适合单线程大量字符串拼接。</p></li><li><p><strong>StringBuffer：</strong> <strong>可变</strong>字符序列。<strong>线程安全</strong>（方法加了 synchronized），效率较低。</p></li></ul><h4 id="_2-和-equals-的区别" tabindex="-1">2. == 和 equals 的区别？ <a class="header-anchor" href="#_2-和-equals-的区别" aria-label="Permalink to “2. == 和 equals 的区别？”">​</a></h4><ul><li><p><strong>==：</strong></p><ul><li><p>基本数据类型：比较<strong>值</strong>。</p></li><li><p>引用数据类型：比较<strong>内存地址</strong>。</p></li></ul></li><li><p><strong>equals：</strong></p><ul><li><p>默认情况（Object类）：等价于 ==，比较内存地址。</p></li><li><p>重写后（如 String, Integer）：比较对象的<strong>内容</strong>。</p></li></ul></li><li><p><strong>追问：为什么要重写 hashCode？</strong></p><ul><li><p><strong>约定：</strong> 如果两个对象 equals 为 true，它们的 hashCode 必须相同。</p></li><li><p><strong>后果：</strong> 如果只重写 equals 不重写 hashCode，放在 HashMap 中会无法根据 Key 找到 Value（因为 HashMap 先算 Hash 确定位置）。</p></li></ul></li></ul><h4 id="_3-接口-interface-和抽象类-abstract-class-的区别" tabindex="-1">3. 接口（Interface）和抽象类（Abstract Class）的区别？ <a class="header-anchor" href="#_3-接口-interface-和抽象类-abstract-class-的区别" aria-label="Permalink to “3. 接口（Interface）和抽象类（Abstract Class）的区别？”">​</a></h4><ul><li><p><strong>语法层面：</strong></p><ul><li><p>接口只能有 public abstract 方法（JDK 8+ 可以有 default/static 方法），变量只能是 public static final 常量。</p></li><li><p>抽象类可以有普通方法和普通成员变量。</p></li></ul></li><li><p><strong>设计层面：</strong></p><ul><li><p>接口是对<strong>行为</strong>的抽象（Can-Do，比如“会飞”）。支持<strong>多实现</strong>。</p></li><li><p>抽象类是对<strong>事物</strong>的抽象（Is-A，比如“是鸟”）。只能<strong>单继承</strong>。</p></li></ul></li></ul><hr><h2 id="并发编程-juc-基础" tabindex="-1">并发编程（JUC）基础 <a class="header-anchor" href="#并发编程-juc-基础" aria-label="Permalink to “并发编程（JUC）基础”">​</a></h2><h3 id="i-volatile-关键字的作用" tabindex="-1">I. volatile 关键字的作用？ <a class="header-anchor" href="#i-volatile-关键字的作用" aria-label="Permalink to “I. volatile 关键字的作用？”">​</a></h3><ul><li><p><strong>保证可见性：</strong> 一个线程修改了变量，其他线程立刻可见（强制刷回主内存）。</p></li><li><p><strong>禁止指令重排序：</strong> 保证代码执行顺序，防止编译器/CPU 乱序执行（经典案例：单例模式的双重检查锁 DCL）。</p></li><li><p><strong>注意：</strong> volatile <strong>不保证原子性</strong>（比如 count++ 操作即使加了 volatile 也是不安全的）。</p></li></ul><h3 id="ii-线程池的-7-个核心参数-threadpoolexecutor" tabindex="-1">II. 线程池的 7 个核心参数（ThreadPoolExecutor）？ <a class="header-anchor" href="#ii-线程池的-7-个核心参数-threadpoolexecutor" aria-label="Permalink to “II. 线程池的 7 个核心参数（ThreadPoolExecutor）？”">​</a></h3><p>这是必背题，顺序不能乱：</p><ol><li><p><strong>corePoolSize：</strong> 核心线程数（常驻线程）。</p></li><li><p><strong>maximumPoolSize：</strong> 最大线程数。</p></li><li><p><strong>keepAliveTime：</strong> 非核心线程空闲存活时间。</p></li><li><p><strong>unit：</strong> 时间单位。</p></li><li><p><strong>workQueue：</strong> 阻塞队列（存放任务的地方，如 ArrayBlockingQueue）。</p></li><li><p><strong>threadFactory：</strong> 线程工厂（用于给线程命名）。</p></li><li><p><strong>handler：</strong> <strong>拒绝策略</strong>（队列满且线程数达到最大时怎么处理）。</p><ul><li><p>AbortPolicy（默认）：抛异常。</p></li><li><p>CallerRunsPolicy：谁调用的谁去执行（比如主线程）。</p></li><li><p>DiscardPolicy：直接丢弃。</p></li><li><p>DiscardOldestPolicy：丢弃队列里最老的。</p></li></ul></li></ol><h3 id="iii-threadlocal-是什么-有没有内存泄漏问题" tabindex="-1">III. ThreadLocal 是什么？有没有内存泄漏问题？ <a class="header-anchor" href="#iii-threadlocal-是什么-有没有内存泄漏问题" aria-label="Permalink to “III. ThreadLocal 是什么？有没有内存泄漏问题？”">​</a></h3><ul><li><p><strong>作用：</strong> 线程本地变量。每个线程有一份独立的副本，互不干扰（空间换时间）。</p></li><li><p><strong>底层：</strong> 每个 Thread 内部维护了一个 ThreadLocalMap。Key 是 ThreadLocal 实例本身，Value 是存储的值。</p></li><li><p><strong>内存泄漏问题：</strong></p><ul><li><p><strong>原因：</strong> ThreadLocalMap 的 Key 是<strong>弱引用</strong>，Value 是<strong>强引用</strong>。如果 ThreadLocal 对象被回收，Key 变成 null，但 Value 还在，且被线程持有，导致 Value 无法回收。</p></li><li><p><strong>解决：</strong> 使用完必须手动调用 <strong>remove()</strong> 方法。</p></li></ul></li></ul><hr><h2 id="java-io-模型" tabindex="-1">Java IO 模型 <a class="header-anchor" href="#java-io-模型" aria-label="Permalink to “Java IO 模型”">​</a></h2><h3 id="i-bio、nio、aio-的区别" tabindex="-1">I. BIO、NIO、AIO 的区别？ <a class="header-anchor" href="#i-bio、nio、aio-的区别" aria-label="Permalink to “I. BIO、NIO、AIO 的区别？”">​</a></h3><ul><li><p><strong>BIO (Blocking I/O - 同步阻塞)：</strong></p><ul><li><strong>模型：</strong> 传统 IO，<strong>一个连接一个线程</strong>。</li><li><strong>流程：</strong> 客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。</li><li><strong>场景：</strong> 适用于连接数目比较小且固定的架构。</li></ul></li><li><p><strong>NIO (Non-blocking I/O - 同步非阻塞)：</strong></p><ul><li><strong>模型：</strong> <strong>多路复用</strong>。<strong>一个线程处理多个连接</strong>。</li><li><strong>核心：</strong> Selectors（选择器）、Channels（通道）、Buffers（缓冲区）。</li><li><strong>流程：</strong> 客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动线程处理。</li><li><strong>场景：</strong> 适用于连接数目多且连接比较短（轻操作）的架构，如聊天服务器、弹幕系统、Netty。</li></ul></li><li><p><strong>AIO (Asynchronous I/O - 异步非阻塞)：</strong></p><ul><li><strong>模型：</strong> <strong>Proactor 模式</strong>。</li><li><strong>流程：</strong> 读写操作由操作系统完成后，再回调通知应用。</li><li><strong>场景：</strong> 适用于连接数目多且连接比较长（重操作）的架构。</li></ul></li></ul><h3 id="ii-什么是-io-多路复用" tabindex="-1">II. 什么是 IO 多路复用？ <a class="header-anchor" href="#ii-什么是-io-多路复用" aria-label="Permalink to “II. 什么是 IO 多路复用？”">​</a></h3><ul><li><strong>概念：</strong> 单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流。</li><li><strong>底层实现 (Linux)：</strong><ul><li><strong>select：</strong> 轮询方式，监视文件描述符。缺点：最大连接数受限 (1024)，轮询效率低 O(N)。</li><li><strong>poll：</strong> 也是轮询，虽然解决了连接数限制（链表存储），但效率依然是 O(N)。</li><li><strong>epoll：</strong> <strong>事件驱动</strong>。只管“活跃”的连接，无需遍历所有连接。效率 O(1)。<strong>是目前 Linux 下最高效的 IO 模型</strong>。</li></ul></li></ul><h3 id="iii-零拷贝-zero-copy-是什么" tabindex="-1">III. 零拷贝 (Zero Copy) 是什么？ <a class="header-anchor" href="#iii-零拷贝-zero-copy-是什么" aria-label="Permalink to “III. 零拷贝 (Zero Copy) 是什么？”">​</a></h3><ul><li><strong>传统 IO：</strong> 数据需要在<strong>用户态</strong>和<strong>内核态</strong>之间多次全量拷贝 (磁盘 -&gt; 内核 -&gt; 用户 -&gt; 内核 -&gt; 网卡)，CPU 消耗大。</li><li><strong>零拷贝：</strong> 减少上下文切换和数据拷贝次数。 <ul><li><strong>mmap (内存映射)：</strong> 将文件映射到内核缓冲区，用户空间共享这块内存，减少一次拷贝。</li><li><strong>sendfile：</strong> 数据直接从内核缓冲区复制到 Socket 缓冲区 (或利用 DMA 直接传给网卡)，<strong>完全不需要经过用户态</strong>。</li></ul></li><li><strong>应用：</strong> Kafka、Netty 极其依赖零拷贝技术来提升吞吐量。</li></ul>',40)])])}const d=l(a,[["render",n]]);export{u as __pageData,d as default};
