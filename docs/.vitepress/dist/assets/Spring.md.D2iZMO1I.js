import{_ as r,c as o,o as n,ah as s}from"./chunks/framework.BqUCKHOO.js";const c=JSON.parse('{"title":"IOC","description":"","frontmatter":{},"headers":[],"relativePath":"Spring.md","filePath":"Spring.md"}'),e={name:"Spring.md"};function a(i,t,l,g,p,d){return n(),o("div",null,[...t[0]||(t[0]=[s('<h1 id="ioc" tabindex="-1">IOC <a class="header-anchor" href="#ioc" aria-label="Permalink to “IOC”">​</a></h1><h3 id="_1-定义" tabindex="-1">1. 定义 <a class="header-anchor" href="#_1-定义" aria-label="Permalink to “1. 定义”">​</a></h3><p>IOC即控制反转，是Spring的一个核心特性，它支持将对象实例统一交给IOC容器进行管理，DI即依赖注入，是 IoC 的具体<strong>实现方式</strong>。容器在运行期间，动态地通过@Resource、@Autowired或构造器注入来将某种依赖关系注入到对象之中。</p><p>好处有：</p><ul><li><p><strong>解耦</strong>：对象之间不再硬编码依赖，方便替换实现类，使得程序的体系结构灵活。</p></li><li><p><strong>易于测试</strong>：可以通过 Mock 轻易替换掉复杂的依赖。</p></li><li><p><strong>集中管理</strong>：对象的生命周期由容器统一配置，更加规范。</p></li></ul><h3 id="_2-生命周期" tabindex="-1">2. 生命周期 <a class="header-anchor" href="#_2-生命周期" aria-label="Permalink to “2. 生命周期”">​</a></h3><p><strong>Bean 的生命周期是怎样的？（重点，建议背诵核心步骤）</strong></p><ol><li><p><strong>实例化</strong>（Instantiate）：JVM 给对象分配空间（即 new）。</p></li><li><p><strong>属性赋值</strong>（Populate）：解析 @Autowired 等，注入依赖。</p></li><li><p><strong>初始化</strong>（Initialization）：</p><ul><li><p>执行各种 Aware 接口方法（获取 BeanName, BeanFactory 等）。</p></li><li><p>执行 BeanPostProcessor 的<strong>前置</strong>处理。</p></li><li><p>执行 @PostConstruct 或 init-method。</p></li><li><p>执行 BeanPostProcessor 的<strong>后置</strong>处理（<strong>AOP 在这里发生</strong>）。</p></li></ul></li><li><p><strong>销毁</strong>（Destruction）：执行 @PreDestroy 或 destroy-method。</p></li></ol><p><strong>注入方式有哪些？</strong></p><ul><li><p><strong>构造器注入</strong>@RequiredConstructArgs（Spring 推荐：保证依赖不为空，避免循环依赖）。</p></li><li><p><strong>Setter 注入</strong>（可选依赖）。</p></li><li><p><strong>注解注入</strong>（@Autowired、@Resource）。</p></li></ul><h3 id="_3-进阶" tabindex="-1">3. 进阶 <a class="header-anchor" href="#_3-进阶" aria-label="Permalink to “3. 进阶”">​</a></h3><p><strong>Spring 如何解决循环依赖？</strong></p><ul><li><p>Spring 通过<strong>三级缓存</strong>解决了<strong>单例 Setter 注入</strong>的循环依赖。</p><ul><li><p><strong>一级缓存</strong>：存放完全初始化好的成品 Bean。</p></li><li><p><strong>二级缓存</strong>：存放半成品 Bean（已实例化但未填充属性）。</p></li><li><p><strong>三级缓存</strong>：存放 ObjectFactory（工厂 Lambda），用于处理 AOP 代理对象的提前暴露。</p></li></ul></li><li><p>注意：构造器循环依赖无法解决（会报 BeanCurrentlyInCreationException），其实循环依赖应该在编码阶段就要尽量避免。</p></li></ul><h1 id="aop" tabindex="-1">AOP <a class="header-anchor" href="#aop" aria-label="Permalink to “AOP”">​</a></h1><blockquote><p>AOP即面向切面编程，它将非业务功能的一些通用功能组件（如日志增强、信息缓存等）通用操作统一封装，并通过注解等方式在业务方法中的横切关注点注入这些增强代码，做到了公用代码逻辑的复用与解耦，提高了系统的可维护性和健壮性。</p></blockquote><h3 id="_1-身份声明-你是谁" tabindex="-1">1. 身份声明：你是谁？ <a class="header-anchor" href="#_1-身份声明-你是谁" aria-label="Permalink to “1. 身份声明：你是谁？”">​</a></h3><ul><li><p><strong>@Aspect</strong>：告诉 Spring，“我是一个切面类，我里面写了拦截逻辑”。</p></li><li><p><strong>@Component</strong>：告诉 Spring，“请把我也当成一个 Bean 存到容器里”，否则切面不会生效。</p></li></ul><h3 id="_2-目标定位-在哪里干" tabindex="-1">2. 目标定位（在哪里干？）： <a class="header-anchor" href="#_2-目标定位-在哪里干" aria-label="Permalink to “2. 目标定位（在哪里干？）：”">​</a></h3><ul><li><p><strong>@Pointcut + 表达式</strong>：这就像是一个“<strong>过滤器</strong>”或者“<strong>扫描范围</strong>”。</p><ul><li><p>它定义了哪些类的哪些方法需要被增强（被拦截）。</p></li><li><p>它本身不写逻辑，只是起一个“起名字”的作用，方便后面引用。</p></li></ul></li></ul><h3 id="_3-通知与逻辑-什么时候干-干什么" tabindex="-1">3. 通知与逻辑（什么时候干？干什么？）： <a class="header-anchor" href="#_3-通知与逻辑-什么时候干-干什么" aria-label="Permalink to “3. 通知与逻辑（什么时候干？干什么？）：”">​</a></h3><ul><li><p><strong>通知注解（@Before / @After 等）</strong>：指定了<strong>“什么时候干”</strong>（是在目标方法执行前、后，还是异常时）。</p></li><li><p><strong>注解指向的 Pointcut</strong>：关联了<strong>“在哪里干”</strong>（引用刚才定义好的切入点名称）。</p></li><li><p><strong>方法体内的代码</strong>：就是具体的<strong>“增强逻辑”</strong>（即：干什么，比如打印日志、检查权限）。</p></li></ul><table tabindex="0"><thead><tr><th><strong>@Aspect</strong></th><th>切面声明</th><th>声明该类是一个切面类，包含通知和切入点。</th></tr></thead><tbody><tr><td><strong>@Pointcut</strong></td><td>切入点</td><td>定义拦截规则（哪些类的哪些方法需要被拦截）。避免重复写 execution 表达式。</td></tr><tr><td><strong>@Before</strong></td><td>前置通知</td><td>在目标方法<strong>执行前</strong>运行。常用于权限校验、参数预处理。</td></tr><tr><td><strong>@After</strong></td><td>后置通知</td><td>在目标方法<strong>执行后</strong>运行（不论成功或异常）。常用于释放资源。</td></tr><tr><td><strong>@AfterReturning</strong></td><td>返回通知</td><td>在目标方法<strong>正常完成后</strong>运行。可以获取并处理方法的返回值。</td></tr><tr><td><strong>@AfterThrowing</strong></td><td>异常通知</td><td>在目标方法<strong>抛出异常后</strong>运行。用于异常监控、日志报警。</td></tr><tr><td><strong>@Around</strong></td><td>环绕通知</td><td><strong>功能最全</strong>。包围了整个方法执行。可以手动控制 proceed() 的调用，甚至替换返回值。</td></tr></tbody></table>',22)])])}const u=r(e,[["render",a]]);export{c as __pageData,u as default};
