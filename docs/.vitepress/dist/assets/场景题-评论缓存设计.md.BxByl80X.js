import{_ as t,c as a,o as i,aj as l}from"./chunks/framework.BZD6ashX.js";const m=JSON.parse('{"title":"评论缓存设计","description":"","frontmatter":{},"headers":[],"relativePath":"场景题-评论缓存设计.md","filePath":"场景题-评论缓存设计.md"}'),n={name:"场景题-评论缓存设计.md"};function o(r,e,_,p,c,s){return i(),a("div",null,[...e[0]||(e[0]=[l('<h1 id="评论缓存设计" tabindex="-1">评论缓存设计 <a class="header-anchor" href="#评论缓存设计" aria-label="Permalink to “评论缓存设计”">​</a></h1><h3 id="_1-业务场景" tabindex="-1">1. 业务场景 <a class="header-anchor" href="#_1-业务场景" aria-label="Permalink to “1. 业务场景”">​</a></h3><p>在高并发系统中，评论经常被查看与点赞，我们在展示评论列表的时候，按点赞数和评论时间综合排序，对于评论业务，应该如何设计缓存策略？</p><h3 id="_2-技术选型" tabindex="-1">2.技术选型 <a class="header-anchor" href="#_2-技术选型" aria-label="Permalink to “2.技术选型”">​</a></h3><p>评论是一种需要持久化的数据，主储存靠考虑使用TiDB等高性能关系数据库，通过合理的表设计来解决缓存大key的问题。</p><p><strong>1️⃣ 评论主题表（Comment Topic）</strong></p><p>作用：评论的“桶”</p><p>comment_topic</p><ul><li>topic_id (视频 / 帖子 / 商品)</li><li>comment_count</li><li>hot_count</li><li>status</li></ul><p>为什么要单独一层？</p><p>评论总数、关闭评论、风控</p><p>快速判断：有没有评论</p><p>避免每次都扫评论表这是“评论的元数据层”</p><p><strong>2️⃣ 评论索引表（Comment Index）</strong></p><p>存放评论的索引与树形结构，表示评论的回复、父子等关系</p><p>comment_index</p><ul><li>topic_id</li><li>comment_id</li><li>parent_id</li><li>order_key (时间 / 热度 / 综合权重)</li><li>level</li></ul><p>不存 content，一条记录非常小，专门为：分页/排序/层级业务设计</p><p><strong>3️⃣ 评论内容表（Comment Content）</strong> comment_content</p><ul><li>comment_id</li><li>user_id</li><li>content</li><li>extra (图片 / 表情 / @)</li></ul><p>这一层的特点为IO 重、字段多、更新少，天然适合缓存</p><h3 id="_3-总结" tabindex="-1">3.总结 <a class="header-anchor" href="#_3-总结" aria-label="Permalink to “3.总结”">​</a></h3><p>这套技术架构核心在表设计上，将评论内容与评论结构进行了解耦，在实际实现的时候，我们只缓存评论内容，可以考虑使用异步编排来进一步优化整体响应时间。</p>',23)])])}const h=t(n,[["render",o]]);export{m as __pageData,h as default};
