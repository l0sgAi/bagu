import{_ as l,c as a,o as t,ah as n}from"./chunks/framework.BqUCKHOO.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Java与数据结构基础.md","filePath":"Java与数据结构基础.md"}'),o={name:"Java与数据结构基础.md"};function s(i,r,e,p,g,h){return t(),a("div",null,[...r[0]||(r[0]=[n('<h3 id="_1-hashmap-与-concurrenthashmap-的底层实现" tabindex="-1">1. HashMap 与 ConcurrentHashMap 的底层实现 <a class="header-anchor" href="#_1-hashmap-与-concurrenthashmap-的底层实现" aria-label="Permalink to “1. HashMap 与 ConcurrentHashMap 的底层实现”">​</a></h3><p>这是重灾区，一定要分 JDK 1.7 和 1.8 两个版本回答，体现深度。</p><h4 id="hashmap" tabindex="-1"><strong>HashMap</strong> <a class="header-anchor" href="#hashmap" aria-label="Permalink to “HashMap”">​</a></h4><ul><li><p><strong>底层结构：</strong></p><ul><li><p><strong>JDK 1.7：</strong> 数组 + 链表。</p></li><li><p><strong>JDK 1.8：</strong> 数组 + 链表 + <strong>红黑树</strong>。</p><ul><li>转换条件： 当链表长度大于 8 <strong>且</strong> 数组长度大于 64 时，链表转为红黑树（查找从 <code>O(n)</code> 优化为<code> O(logn)</code>）；当节点少于 6 时退化为链表。</li></ul></li></ul></li><li><p><strong>扩容机制：</strong></p><ul><li><p>默认初始容量 16，加载因子 0.75。</p></li><li><p>当元素个数 &gt; 容量 * 加载因子时，扩容为原来的 <strong>2倍</strong>。</p></li></ul></li><li><p><strong>线程安全性：</strong> 不安全。多线程下扩容可能导致死循环（1.7）或数据覆盖（1.8）。</p></li></ul><h4 id="concurrenthashmap-chm" tabindex="-1"><strong>ConcurrentHashMap (CHM)</strong> <a class="header-anchor" href="#concurrenthashmap-chm" aria-label="Permalink to “ConcurrentHashMap (CHM)”">​</a></h4><ul><li><p><strong>JDK 1.7（分段锁）：</strong></p><ul><li><p><strong>结构：</strong> Segment 数组 + HashEntry 数组。</p></li><li><p><strong>锁机制：</strong> Segment 继承自 ReentrantLock。将数据分成一段一段存储，给每一段数据配一把锁。</p></li><li><p><strong>并发度：</strong> 默认 16（即支持 16 个线程并发写）。</p></li></ul></li><li><p><strong>JDK 1.8（CAS + synchronized）：</strong></p><ul><li><p><strong>结构：</strong> 与 HashMap 1.8 一致（数组 + 链表 + 红黑树）。</p></li><li><p><strong>锁机制：</strong> 抛弃了分段锁。使用 <strong>CAS</strong> 添加新节点，使用 <strong>synchronized</strong> 锁定链表或树的<strong>首节点</strong>。</p></li><li><p><strong>优势：</strong> 锁粒度更细（只锁当前桶），并发性能更高。</p></li></ul></li></ul><hr><h3 id="_2-arraylist-的底层实现" tabindex="-1">2. ArrayList 的底层实现 <a class="header-anchor" href="#_2-arraylist-的底层实现" aria-label="Permalink to “2. ArrayList 的底层实现”">​</a></h3><ul><li><p><strong>底层数据结构：</strong> 动态数组（Object[] elementData）。</p></li><li><p><strong>初始容量：</strong> 默认为 10（注意：JDK 1.8+ 是懒加载，第一次 add 时才初始化数组）。</p></li><li><p><strong>扩容机制：</strong></p><ul><li><p>当容量不足时，扩容为原来的 <strong>1.5 倍</strong>（oldCapacity + (oldCapacity &gt;&gt; 1)）。</p></li><li><p>扩容本质是 System.arraycopy，将老数组元素复制到新数组，比较耗时。</p></li></ul></li><li><p><strong>特点：</strong></p><ul><li><p>支持随机访问（根据下标查询），时间复杂度 O(1)</p><p>。</p></li><li><p>插入/删除效率低（因为要移动后续元素），时间复杂度 O(n)</p><p>。</p></li></ul></li><li><p><strong>线程安全：</strong> 不安全。并发场景建议使用 CopyOnWriteArrayList。</p></li></ul><hr><h3 id="_3-哈希冲突-hash-collision-怎么解决" tabindex="-1">3. 哈希冲突（Hash Collision）怎么解决？ <a class="header-anchor" href="#_3-哈希冲突-hash-collision-怎么解决" aria-label="Permalink to “3. 哈希冲突（Hash Collision）怎么解决？”">​</a></h3><p>面试官通常想听前两种，特别是第一种。</p><ol><li><p><strong>链地址法（拉链法 - Chaining）：</strong></p><ul><li><p><strong>原理：</strong> 数组的每个槽位指向一个链表，所有哈希值相同的元素都存在链表中。</p></li><li><p><strong>应用：</strong> <strong>Java 的 HashMap</strong> 就是用的这种（1.8 后链表过长转红黑树）。</p></li></ul></li><li><p><strong>开放寻址法（Open Addressing）：</strong></p><ul><li><p><strong>原理：</strong> 发生冲突时，去寻找下一个空的槽位。常见方式有线性探测（+1, +2...）或二次探测。</p></li><li><p><strong>应用：</strong> Java 的 <strong>ThreadLocalMap</strong>。</p></li></ul></li><li><p><strong>再哈希法（Re-Hashing）：</strong></p><ul><li>准备多个哈希函数，第一个冲突了就用第二个，直到不冲突为止。</li></ul></li><li><p><strong>公共溢出区法：</strong></p><ul><li>建立一个公共的溢出区（通常也是数组），凡是冲突的元素都扔进去。</li></ul></li></ol><hr><h3 id="_4-其它" tabindex="-1">4. 其它 <a class="header-anchor" href="#_4-其它" aria-label="Permalink to “4. 其它”">​</a></h3><h4 id="_1-string、stringbuffer、stringbuilder-的区别" tabindex="-1">1. String、StringBuffer、StringBuilder 的区别？ <a class="header-anchor" href="#_1-string、stringbuffer、stringbuilder-的区别" aria-label="Permalink to “1. String、StringBuffer、StringBuilder 的区别？”">​</a></h4><ul><li><p><strong>String：</strong> <strong>不可变</strong>字符序列（底层是 final char[]，JDK9改为 byte[]）。每次修改都会创建新对象，适合少量操作。</p></li><li><p><strong>StringBuilder：</strong> <strong>可变</strong>字符序列。<strong>线程不安全</strong>，效率最高。适合单线程大量字符串拼接。</p></li><li><p><strong>StringBuffer：</strong> <strong>可变</strong>字符序列。<strong>线程安全</strong>（方法加了 synchronized），效率较低。</p></li></ul><h4 id="_2-和-equals-的区别" tabindex="-1">2. == 和 equals 的区别？ <a class="header-anchor" href="#_2-和-equals-的区别" aria-label="Permalink to “2. == 和 equals 的区别？”">​</a></h4><ul><li><p><strong>==：</strong></p><ul><li><p>基本数据类型：比较<strong>值</strong>。</p></li><li><p>引用数据类型：比较<strong>内存地址</strong>。</p></li></ul></li><li><p><strong>equals：</strong></p><ul><li><p>默认情况（Object类）：等价于 ==，比较内存地址。</p></li><li><p>重写后（如 String, Integer）：比较对象的<strong>内容</strong>。</p></li></ul></li><li><p><strong>追问：为什么要重写 hashCode？</strong></p><ul><li><p><strong>约定：</strong> 如果两个对象 equals 为 true，它们的 hashCode 必须相同。</p></li><li><p><strong>后果：</strong> 如果只重写 equals 不重写 hashCode，放在 HashMap 中会无法根据 Key 找到 Value（因为 HashMap 先算 Hash 确定位置）。</p></li></ul></li></ul><h4 id="_3-接口-interface-和抽象类-abstract-class-的区别" tabindex="-1">3. 接口（Interface）和抽象类（Abstract Class）的区别？ <a class="header-anchor" href="#_3-接口-interface-和抽象类-abstract-class-的区别" aria-label="Permalink to “3. 接口（Interface）和抽象类（Abstract Class）的区别？”">​</a></h4><ul><li><p><strong>语法层面：</strong></p><ul><li><p>接口只能有 public abstract 方法（JDK 8+ 可以有 default/static 方法），变量只能是 public static final 常量。</p></li><li><p>抽象类可以有普通方法和普通成员变量。</p></li></ul></li><li><p><strong>设计层面：</strong></p><ul><li><p>接口是对<strong>行为</strong>的抽象（Can-Do，比如“会飞”）。支持<strong>多实现</strong>。</p></li><li><p>抽象类是对<strong>事物</strong>的抽象（Is-A，比如“是鸟”）。只能<strong>单继承</strong>。</p></li></ul></li></ul><hr><h3 id="第二板块-并发编程-juc-基础" tabindex="-1">第二板块：并发编程（JUC）基础 <a class="header-anchor" href="#第二板块-并发编程-juc-基础" aria-label="Permalink to “第二板块：并发编程（JUC）基础”">​</a></h3><h4 id="_4-volatile-关键字的作用" tabindex="-1">4. volatile 关键字的作用？ <a class="header-anchor" href="#_4-volatile-关键字的作用" aria-label="Permalink to “4. volatile 关键字的作用？”">​</a></h4><ul><li><p><strong>保证可见性：</strong> 一个线程修改了变量，其他线程立刻可见（强制刷回主内存）。</p></li><li><p><strong>禁止指令重排序：</strong> 保证代码执行顺序，防止编译器/CPU 乱序执行（经典案例：单例模式的双重检查锁 DCL）。</p></li><li><p><strong>注意：</strong> volatile <strong>不保证原子性</strong>（比如 count++ 操作即使加了 volatile 也是不安全的）。</p></li></ul><h4 id="_5-线程池的-7-个核心参数-threadpoolexecutor" tabindex="-1">5. 线程池的 7 个核心参数（ThreadPoolExecutor）？ <a class="header-anchor" href="#_5-线程池的-7-个核心参数-threadpoolexecutor" aria-label="Permalink to “5. 线程池的 7 个核心参数（ThreadPoolExecutor）？”">​</a></h4><p>这是必背题，顺序不能乱：</p><ol><li><p><strong>corePoolSize：</strong> 核心线程数（常驻线程）。</p></li><li><p><strong>maximumPoolSize：</strong> 最大线程数。</p></li><li><p><strong>keepAliveTime：</strong> 非核心线程空闲存活时间。</p></li><li><p><strong>unit：</strong> 时间单位。</p></li><li><p><strong>workQueue：</strong> 阻塞队列（存放任务的地方，如 ArrayBlockingQueue）。</p></li><li><p><strong>threadFactory：</strong> 线程工厂（用于给线程命名）。</p></li><li><p><strong>handler：</strong> <strong>拒绝策略</strong>（队列满且线程数达到最大时怎么处理）。</p><ul><li><p>AbortPolicy（默认）：抛异常。</p></li><li><p>CallerRunsPolicy：谁调用的谁去执行（比如主线程）。</p></li><li><p>DiscardPolicy：直接丢弃。</p></li><li><p>DiscardOldestPolicy：丢弃队列里最老的。</p></li></ul></li></ol><h4 id="_6-threadlocal-是什么-有没有内存泄漏问题" tabindex="-1">6. ThreadLocal 是什么？有没有内存泄漏问题？ <a class="header-anchor" href="#_6-threadlocal-是什么-有没有内存泄漏问题" aria-label="Permalink to “6. ThreadLocal 是什么？有没有内存泄漏问题？”">​</a></h4><ul><li><p><strong>作用：</strong> 线程本地变量。每个线程有一份独立的副本，互不干扰（空间换时间）。</p></li><li><p><strong>底层：</strong> 每个 Thread 内部维护了一个 ThreadLocalMap。Key 是 ThreadLocal 实例本身，Value 是存储的值。</p></li><li><p><strong>内存泄漏问题：</strong></p><ul><li><p><strong>原因：</strong> ThreadLocalMap 的 Key 是<strong>弱引用</strong>，Value 是<strong>强引用</strong>。如果 ThreadLocal 对象被回收，Key 变成 null，但 Value 还在，且被线程持有，导致 Value 无法回收。</p></li><li><p><strong>解决：</strong> 使用完必须手动调用 <strong>remove()</strong> 方法。</p></li></ul></li></ul><hr>',31)])])}const d=l(o,[["render",s]]);export{u as __pageData,d as default};
