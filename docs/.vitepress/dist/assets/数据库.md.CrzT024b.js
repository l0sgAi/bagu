import{_ as i,c as l,o as n,aj as t}from"./chunks/framework.BZD6ashX.js";const d=JSON.parse('{"title":"📚数据库相关","description":"","frontmatter":{},"headers":[],"relativePath":"数据库.md","filePath":"数据库.md"}'),a={name:"数据库.md"};function p(r,s,o,g,e,h){return n(),l("div",null,[...s[0]||(s[0]=[t(`<h1 id="📚数据库相关" tabindex="-1">📚数据库相关 <a class="header-anchor" href="#📚数据库相关" aria-label="Permalink to “📚数据库相关”">​</a></h1><h3 id="i-数据库-acid-指的是什么" tabindex="-1">I. 数据库 ACID 指的是什么？ <a class="header-anchor" href="#i-数据库-acid-指的是什么" aria-label="Permalink to “I. 数据库 ACID 指的是什么？”">​</a></h3><p>ACID 是事务（Transaction）的四个基本特性，用来保证数据库操作的可靠性。</p><ul><li><p><strong>A - Atomicity（原子性）：</strong></p><ul><li><p><strong>定义：</strong> 事务包含的所有操作要么全部成功，要么全部失败回滚，不存在中间状态。</p></li><li><p><strong>实现原理（加分项）：</strong> 依赖 <strong>Undo Log（回滚日志）</strong>。如果事务失败，数据库利用 Undo Log 将数据回滚到事务开始前的状态。</p></li></ul></li><li><p><strong>C - Consistency（一致性）：</strong></p><ul><li><p><strong>定义：</strong> 事务执行前后，数据库必须从一个一致性状态变换到另一个一致性状态。比如转账，A 扣钱，B 必须加钱，总金额不变。</p></li><li><p><strong>备注：</strong> 这是最终目标，A、I、D 都是为了保证 C。</p></li></ul></li><li><p><strong>I - Isolation（隔离性）：</strong></p><ul><li><p><strong>定义：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。</p></li><li><p><strong>实现原理（加分项）：</strong> 依赖 <strong>锁（Lock）</strong> 和 <strong>MVCC（多版本并发控制）</strong>。</p></li></ul></li><li><p><strong>D - Durability（持久性）：</strong></p><ul><li><p><strong>定义：</strong> 一个事务一旦被提交，它对数据库中数据的改变就是永久性的，即使数据库发生故障也不应该丢失。</p></li><li><p><strong>实现原理（加分项）：</strong> 依赖 <strong>Redo Log（重做日志）</strong>。</p></li></ul></li></ul><hr><h3 id="ii-事务隔离级别有哪几种" tabindex="-1">II. 事务隔离级别有哪几种？ <a class="header-anchor" href="#ii-事务隔离级别有哪几种" aria-label="Permalink to “II. 事务隔离级别有哪几种？”">​</a></h3><p>SQL 标准定义了四个隔离级别，级别越高，安全性越高，但性能越低。</p><ol><li><p><strong>Read Uncommitted（读未提交）：</strong></p><ul><li><p>允许读取尚未提交的数据。</p></li><li><p><strong>问题：</strong> 会出现<strong>脏读</strong>（Dirty Read）。</p></li></ul></li><li><p><strong>Read Committed（读已提交 - RC）：</strong></p><ul><li><p>只能读取已经提交的数据。</p></li><li><p><strong>问题：</strong> 会出现<strong>不可重复读</strong>（同一个事务里两次读到的数据不一样）。</p></li><li><p>Oracle、SQL Server 默认级别。</p></li></ul></li><li><p><strong>Repeatable Read（可重复读 - RR）：</strong></p><ul><li><p>同一个事务中多次读取同样的数据，结果是一致的。</p></li><li><p><strong>问题：</strong> 理论上会出现<strong>幻读</strong>（Phantom Read，即第一次读没有，第二次读突然多了几行数据）。</p></li></ul></li><li><p><strong>Serializable（串行化）：</strong></p><ul><li><p>强制事务串行执行。</p></li><li><p><strong>问题：</strong> 性能极差，极少使用。</p></li></ul></li></ol><hr><h3 id="iii-mysql-是哪一种隔离级别-怎么实现的" tabindex="-1">III. MySQL 是哪一种隔离级别？怎么实现的？ <a class="header-anchor" href="#iii-mysql-是哪一种隔离级别-怎么实现的" aria-label="Permalink to “III. MySQL 是哪一种隔离级别？怎么实现的？”">​</a></h3><p><strong>默认隔离级别：</strong> <strong>Repeatable Read (RR)</strong>。</p><p><strong>面试核心考点：</strong> 标准的 RR 级别解决不了幻读，但 MySQL 的 InnoDB 引擎在 RR 级别下，通过特殊的手段解决了绝大部分幻读问题。</p><p><strong>实现原理（MVCC + 锁）：</strong></p><p>MySQL InnoDB 采用了 <strong>MVCC（多版本并发控制）</strong> 配合 <strong>锁</strong> 来实现隔离级别。</p><ol><li><p><strong>读操作（快照读）：利用 MVCC</strong></p><ul><li><p><strong>原理：</strong> 每个事务开启时会生成一个 Read View（读视图），并通过 Undo Log 维持数据的历史版本链。</p></li><li><p><strong>RC 与 RR 的区别：</strong></p><ul><li><p><strong>RC：</strong> 每次执行 Select 语句时，都会<strong>重新生成</strong>一个 Read View（所以能读到别人刚提交的）。</p></li><li><p><strong>RR：</strong> 只在事务开始后的第一次 Select <strong>生成一次</strong> Read View，之后复用这个视图（所以保证了可重复读）。</p></li></ul></li></ul></li><li><p><strong>写操作/当前读（For Update）：利用锁</strong></p><ul><li><p>为了防止幻读，InnoDB 在 RR 级别下使用了 <strong>Next-Key Lock</strong>（临键锁）。</p></li><li><p><strong>Next-Key Lock = Record Lock（行锁） + Gap Lock（间隙锁）。</strong></p></li><li><p>它不仅锁住记录本身，还锁住记录之间的“间隙”，防止其他事务在这个范围内插入新数据，从而解决了幻读。</p></li></ul></li></ol><hr><h3 id="iv-索引是什么-原理是什么" tabindex="-1">IV. 索引是什么？原理是什么？ <a class="header-anchor" href="#iv-索引是什么-原理是什么" aria-label="Permalink to “IV. 索引是什么？原理是什么？”">​</a></h3><p><strong>索引是什么：</strong><br> 索引是帮助 MySQL 高效获取数据的<strong>数据结构</strong>。可以把它理解为书籍的<strong>目录</strong>。如果没有索引，数据库必须全表扫描（从头翻到尾），效率极低。</p><p><strong>原理：</strong><br> 通过特定的算法（如 B+ 树）将数据组织成有序结构，从而大大减少数据检索时的磁盘 I/O 次数。</p><p><strong>常见类型：</strong></p><ul><li><p><strong>B+ 树索引</strong>（最常用，InnoDB 默认）。</p></li><li><p><strong>Hash 索引</strong>（适合精确匹配，不支持范围查询）。</p></li><li><p><strong>Full-text 全文索引</strong>。</p></li></ul><hr><h3 id="v-索引的设计原则是什么" tabindex="-1">V. 索引的设计原则是什么？ <a class="header-anchor" href="#v-索引的设计原则是什么" aria-label="Permalink to “V. 索引的设计原则是什么？”">​</a></h3><p><strong>一句话总结：</strong><br><strong>“高区分度、核心SQL优先、尽量覆盖、控制数量、短小精悍。”</strong></p><p><strong>详细拆解（记这5点）：</strong></p><ol><li><p><strong>高区分度（Cardinality）优先：</strong></p><ul><li><p>索引列的数据重复率越低越好。</p></li><li><p><strong>例子：</strong> UUID、手机号、身份证 适合做索引；性别、状态（只有0/1）不适合（因为你要扫描一半的表，数据库优化器可能直接选择全表扫描）。</p></li></ul></li><li><p><strong>针对核心查询设计（最左前缀）：</strong></p><ul><li><p>不要为每个字段单独建索引，而是根据业务 SQL 的 WHERE、ORDER BY、GROUP BY 字段建立<strong>联合索引</strong>。</p></li><li><p>遵循<strong>最左前缀法则</strong>，把最常用的筛选字段放在最左边。</p></li></ul></li><li><p><strong>尽量使用覆盖索引：</strong></p><ul><li>设计索引时，尽量让索引包含查询所需的所有字段，避免<strong>回表</strong>，性能提升巨大。</li></ul></li><li><p><strong>控制索引数量：</strong></p><ul><li><p>索引不是越多越好。索引会占用磁盘空间，且会降低 INSERT、UPDATE、DELETE 的速度（因为要维护索引树）。</p></li><li><p>一般单表索引不超过 5 个。</p></li></ul></li><li><p><strong>索引字段要短（前缀索引）：</strong></p><ul><li>如果是长字符串（如 varchar(255)），尽量指定<strong>前缀长度</strong>（如只索引前 20 个字符），以节省 B+ 树空间，减少 I/O。</li></ul></li></ol><hr><h3 id="vi-为什么使用-b-树-高频考点" tabindex="-1">VI. 为什么使用 B+ 树？（高频考点） <a class="header-anchor" href="#vi-为什么使用-b-树-高频考点" aria-label="Permalink to “VI. 为什么使用 B+ 树？（高频考点）”">​</a></h3><p>面试官通常会问：“为什么不用二叉树？为什么不用 Hash？为什么不用 B 树？”</p><p><strong>答案逻辑：</strong></p><ol><li><p><strong>为什么不用二叉树 / 平衡二叉树（AVL） / 红黑树？</strong></p><ul><li><p><strong>树太高了：</strong> 这些树每个节点只能存储一个数据，当数据量大（百万级）时，树的高度会很高。</p></li><li><p><strong>I/O 代价大：</strong> 数据库索引存储在磁盘上，树的每一层代表一次磁盘 I/O。树越高，查询越慢。B+ 树一个节点可以存很多 Key，树非常“矮胖”（通常 3 层就能存 2000 万数据），I/O 次数少。</p></li></ul></li><li><p><strong>为什么不用 Hash？</strong></p><ul><li><strong>不支持范围查询：</strong> Hash 只能进行等值查询（=, IN），无法处理 &gt; 100 这种范围查询，也无法利用索引排序。</li></ul></li><li><p><strong>为什么不用 B 树（B-Tree），而用 B+ 树？（核心对比）</strong></p><ul><li><p><strong>B 树：</strong> 每个节点（包括叶子和非叶子）都存储 data。</p></li><li><p><strong>B+ 树：</strong> 只有<strong>叶子节点</strong>存储 data，非叶子节点只存 key（索引值）。</p></li><li><p><strong>B+ 树的优势：</strong></p><ol><li><p><strong>范围查询的能力更强：</strong> B+ 树的叶子节点使用<strong>双向链表</strong>连接。如果做范围查询（比如 id &gt; 10），只需要找到 10，然后顺着链表往后取就行了。而 B 树需要进行中序遍历，效率低。</p></li><li><p><strong>磁盘读写代价更低：</strong> 因为非叶子节点不存 data，只存 key，所以一个磁盘块能容纳更多的节点索引，树会更矮，I/O 次数更少。</p></li><li><p><strong>查询效率更稳定：</strong> 任何查询都必须走到叶子节点。</p></li></ol></li></ul></li></ol><h3 id="总结面试回答话术" tabindex="-1">总结面试回答话术： <a class="header-anchor" href="#总结面试回答话术" aria-label="Permalink to “总结面试回答话术：”">​</a></h3><ol><li><p><strong>ACID</strong>：原子、一致、隔离、持久。分别靠 Undo Log、代码逻辑、锁/MVCC、Redo Log 保证。</p></li><li><p><strong>隔离级别</strong>：读未提交、读已提交（RC）、可重复读（RR）、串行化。</p></li><li><p><strong>MySQL</strong>：默认 RR。通过 <strong>MVCC</strong>（解决读）和 <strong>Next-Key Lock</strong>（解决写时的幻读）实现。</p></li><li><p><strong>索引</strong>：数据结构，为了减少 I/O。</p></li><li><p><strong>B+ 树</strong>：因为树矮（减少 I/O）、叶子节点有链表（适合范围查询）、数据都在叶子节点（查询稳定）。</p></li></ol><hr><h3 id="vii-索引失效的情况有哪些-必考" tabindex="-1">VII. 索引失效的情况有哪些？（必考） <a class="header-anchor" href="#vii-索引失效的情况有哪些-必考" aria-label="Permalink to “VII. 索引失效的情况有哪些？（必考）”">​</a></h3><p>只要没用上 B+ 树的快速查找特性，退化成全表扫描，就是失效。记住口诀：<strong>“模运空，最左配，类型错”</strong>。</p><ol><li><p><strong>违反最左前缀法则：</strong></p><ul><li><p>联合索引 (a, b, c)。</p></li><li><p>查询 where b = 1 或 where c = 1 <strong>失效</strong>（跳过了 a）。</p></li><li><p>查询 where a = 1 and c = 1，a 走了索引，c 没走（因为中间断了 b）。</p></li></ul></li><li><p><strong>在索引列上做运算：</strong></p><ul><li><p>where id + 1 = 10 <strong>失效</strong>。应改为 id = 10 - 1。</p></li><li><p>where substring(name, 0, 3) = &#39;abc&#39; <strong>失效</strong>。</p></li></ul></li><li><p><strong>模糊查询 % 在最前面：</strong></p><ul><li><p>where name like &#39;%abc&#39; <strong>失效</strong>（B+ 树是从左往右排的，不知道开头是啥，没法查）。</p></li><li><p>where name like &#39;abc%&#39; <strong>有效</strong>。</p></li></ul></li><li><p><strong>类型隐式转换：</strong></p><ul><li>字段是字符串 varchar，查询用了数字 where phone = 123 <strong>失效</strong>（数据库不仅要把数字转字符串，通常还会因为字符集转换导致全表扫描）。</li></ul></li><li><p><strong>使用 OR 条件：</strong></p><ul><li>where id = 1 or age = 18。如果 id 有索引，age 没索引，整个索引<strong>失效</strong>（因为 age 那边必须全表扫，索性全表扫了）。</li></ul></li><li><p><strong>不等号与 NULL（视情况）：</strong></p><ul><li>!=, &lt;&gt;, IS NULL, IS NOT NULL 在某些版本或数据分布下会导致失效。</li></ul></li></ol><hr><h3 id="viii-spring-事务-为什么不推荐滥用声明式事务" tabindex="-1">VIII. Spring 事务：为什么不推荐滥用声明式事务？ <a class="header-anchor" href="#viii-spring-事务-为什么不推荐滥用声明式事务" aria-label="Permalink to “VIII. Spring 事务：为什么不推荐滥用声明式事务？”">​</a></h3><p>注意：不是“不推荐使用”，而是“不推荐在高性能/复杂业务中<strong>滥用</strong> @Transactional 注解”。</p><p><strong>核心原因：粒度太大，容易长事务。</strong></p><ol><li><p><strong>占用连接时间过长：</strong></p><ul><li><p>@Transactional 加在方法上，意味着进入方法前开启事务，方法<strong>完全结束后</strong>才提交。</p></li><li><p>如果方法里包含 <strong>RPC 调用、HTTP 请求、复杂计算</strong> 或 <strong>文件 I/O</strong>，这些耗时操作都会占用数据库连接。数据库连接池（如 Druid/Hikari）很快会被耗尽，导致系统吞吐量下降。</p></li></ul></li><li><p><strong>锁竞争：</strong></p><ul><li>事务持有锁的时间变长，增加了死锁和锁等待的概率。</li></ul></li></ol><hr><h3 id="ix-声明式事务-transactional-失效的场景-八股文必背" tabindex="-1">IX. 声明式事务（@Transactional）失效的场景？（八股文必背） <a class="header-anchor" href="#ix-声明式事务-transactional-失效的场景-八股文必背" aria-label="Permalink to “IX. 声明式事务（@Transactional）失效的场景？（八股文必背）”">​</a></h3><p>面试官最喜欢问这个，以此判断你有没有踩过坑。</p><ol><li><p><strong>方法不是 public 的：</strong> Spring AOP 默认只拦截 public 方法。</p></li><li><p><strong>同类内部调用（最经典）：</strong></p><ul><li><p>类 A 中有一个 methodA（无事务）调用了 methodB（有事务）。</p></li><li><p><strong>失效原因：</strong> Spring 事务基于 AOP <strong>代理对象</strong>。也就是外部调用类 A 时，是调用了代理。但类内部 this.methodB() 是直接调用的原对象方法，绕过了代理，所以没有切面逻辑。</p></li></ul></li><li><p><strong>异常类型不匹配：</strong></p><ul><li><p>默认情况下，Spring 只在遇到 RuntimeException 或 Error 时回滚。</p></li><li><p>如果抛出的是 Checked Exception（如 IOException, SQLException），事务<strong>不会回滚</strong>。</p></li><li><p><strong>解决：</strong> @Transactional(rollbackFor = Exception.class)。</p></li></ul></li><li><p><strong>未抛出异常：</strong></p><ul><li>你在代码里手动 catch 了异常且没有抛出，代理类以为方法执行成功，就会提交事务。</li></ul></li><li><p><strong>数据库引擎不支持：</strong> 如 MySQL 选了 MyISAM 引擎（不支持事务）。</p></li></ol><hr><h3 id="x-推荐怎么实现事务-编程式事务" tabindex="-1">X. 推荐怎么实现事务？（编程式事务） <a class="header-anchor" href="#x-推荐怎么实现事务-编程式事务" aria-label="Permalink to “X. 推荐怎么实现事务？（编程式事务）”">​</a></h3><p>为了解决“粒度太大”的问题，推荐使用 <strong>编程式事务</strong>。或者在分布式系统中，使用分布式事务中间件。</p><p><strong>工具：</strong> TransactionTemplate。</p><p><strong>代码示例：</strong></p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TransactionTemplate transactionTemplate;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 1. 做一些耗时的非DB操作（如调用第三方API、计算）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    heavyCalculation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2. 只有在真正操作数据库时，才开启事务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    transactionTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            userMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            orderMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(order);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 业务逻辑成功，隐式提交</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Exception </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            status.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setRollbackOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 手动回滚</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            throw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>优点：</strong></p><ol><li><p><strong>锁粒度小：</strong> 事务仅包裹 DB 操作，RPC 等耗时操作在事务外。</p></li><li><p><strong>控制精准：</strong> 开发者完全掌控何时开始、何时提交。</p></li></ol><hr><h3 id="xi-补充题库" tabindex="-1">XI. 补充题库 <a class="header-anchor" href="#xi-补充题库" aria-label="Permalink to “XI. 补充题库”">​</a></h3><p>如果你想拿高薪，以下题目建议准备：</p><ol><li><p><strong>SQL 优化相关：</strong></p><ul><li><p>Explain 命令结果参数怎么看？主要参数如下：</p><ul><li><p>id：优先级，表示每个sql查询的优先级编号</p></li><li><p>select_type：SQL类型，SIMPLE就是简单SQL，无子查询和unit</p></li><li><p>table：操作的表名或别名</p></li><li><p>partitions：分区，分库分表时会用到</p></li><li><p><strong>type(重要)</strong>：查询方式，性能由查到好包括包括<strong>ALL</strong>(全表扫描，需要避免)、<strong>index</strong>(索引全扫描)、<strong>RANGE</strong>(范围索引扫描)、<strong>ref</strong>(使用非唯一性索引或者唯一索引的前缀扫描，返回匹配某个单独值的记录行)、<strong>eq_ref</strong>(相对于ref来说就是使用的是唯一索引，对于每个索引键值，只有唯一的一条匹配记录)、<strong>const/system</strong>(单表中最多只有一条匹配行)</p></li><li><p>possible_keys：可能存在的索引</p></li><li><p>key：正在使用的索引</p></li></ul></li><li><p>如何做慢查询分析？（开启慢查询日志 slow_query_log）。</p></li></ul></li><li><p><strong>锁相关：</strong></p><ul><li><p>乐观锁 vs 悲观锁：悲观锁是“先锁后改”，适合写入多的情况。乐观锁是“改时检查”即在写入时与旧值进行检查，如果不符更新新值再尝试修改，适合读多写少的情况。</p></li><li><p>死锁是怎么产生的？如何排查： 两个事务互相持有对方需要的锁且不释放，形成环路导致死锁；排查靠 show engine innodb status 或死锁日志。</p></li></ul></li><li><p><strong>Redis 与 MySQL 双写一致性：</strong></p><ul><li><p>先删缓存还是先更新数据库？（延时双删）。</p></li><li><p>最佳实践：Canal 监听 Binlog 异步更新缓存。</p></li></ul></li><li><p><strong>分库分表：</strong></p><ul><li><p>什么时候分？（单表超 500w~1000w 或 占用空间过大）。</p></li><li><p>垂直分表 vs 水平分表。</p></li><li><p>分表后分页查询怎么做？</p></li></ul></li><li><p><strong>深分页解决：</strong></p><ul><li><p>游标分页：</p><p>通过一个有序的索引字段作为游标，通过游标来执行分页，缺点是无法跳页。</p></li><li><p>子查询优化： <strong>原理：</strong> 先通过<strong>覆盖索引</strong>（只查主键 ID，不需要回表）快速定位到第 100 万条的位置，拿到这 10 个 ID，然后再去主表查数据的详情。</p><ul><li><p><strong>普通写法（慢）：</strong></p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LIMIT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 慢在：回表了 1000010 次，然后丢弃了前 100 万次结果。</span></span></code></pre></div></li><li><p>**优化写法（快）：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t1.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user t1, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LIMIT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) t2  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 这里只查ID，走覆盖索引，极快</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> t1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> t2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></li></ul></li></ul></li></ol>`,58)])])}const E=i(a,[["render",p]]);export{d as __pageData,E as default};
