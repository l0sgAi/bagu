# 🍀Spring框架相关

---

# I. IOC

### 1. 定义

IOC即控制反转，是Spring的一个核心特性，它支持将对象实例统一交给IOC容器进行管理，DI即依赖注入，是 IoC 的具体**实现方式**。容器在运行期间，动态地通过@Resource、@Autowired或构造器注入来将某种依赖关系注入到对象之中。

好处有：

- **解耦**：对象之间不再硬编码依赖，方便替换实现类，使得程序的体系结构灵活。

- **易于测试**：可以通过 Mock 轻易替换掉复杂的依赖。

- **集中管理**：对象的生命周期由容器统一配置，更加规范。

### 2. 生命周期

 **Bean 的生命周期是怎样的？（重点，建议背诵核心步骤）**

1. **实例化**（Instantiate）：JVM 给对象分配空间（即 new）。

2. **属性赋值**（Populate）：解析 @Autowired 等，注入依赖。

3. **初始化**（Initialization）：
   
   - 执行各种 Aware 接口方法（获取 BeanName, BeanFactory 等）。
   
   - 执行 BeanPostProcessor 的**前置**处理。
   
   - 执行 @PostConstruct 或 init-method。
   
   - 执行 BeanPostProcessor 的**后置**处理（**AOP 在这里发生**）。

4. **销毁**（Destruction）：执行 @PreDestroy 或 destroy-method。

 **注入方式有哪些？**

- **构造器注入**@RequiredConstructArgs（Spring 推荐：保证依赖不为空，避免循环依赖）。

- **Setter 注入**（可选依赖）。

- **注解注入**（@Autowired、@Resource）。

### 3. 进阶

**Spring 如何解决循环依赖？**

- Spring 通过**三级缓存**解决了**单例 Setter 注入**的循环依赖。
  
  - **一级缓存**：存放完全初始化好的成品 Bean。
  
  - **二级缓存**：存放半成品 Bean（已实例化但未填充属性）。
  
  - **三级缓存**：存放 ObjectFactory（工厂 Lambda），用于处理 AOP 代理对象的提前暴露。

- 注意：构造器循环依赖无法解决（会报 BeanCurrentlyInCreationException），其实循环依赖应该在编码阶段就要尽量避免。

---

# II. AOP

> AOP即面向切面编程，它将非业务功能的一些通用功能组件（如日志增强、信息缓存等）通用操作统一封装，并通过注解等方式在业务方法中的横切关注点注入这些增强代码，做到了公用代码逻辑的复用与解耦，提高了系统的可维护性和健壮性。

### 1. 身份声明：你是谁？

- **@Aspect**：告诉 Spring，“我是一个切面类，我里面写了拦截逻辑”。

- **@Component**：告诉 Spring，“请把我也当成一个 Bean 存到容器里”，否则切面不会生效。

### 2. 目标定位（在哪里干？）：

- **@Pointcut + 表达式**：这就像是一个“**过滤器**”或者“**扫描范围**”。
  
  - 它定义了哪些类的哪些方法需要被增强（被拦截）。
  
  - 它本身不写逻辑，只是起一个“起名字”的作用，方便后面引用。

### 3. 通知与逻辑（什么时候干？干什么？）：

- **通知注解（@Before / @After 等）**：指定了**“什么时候干”**（是在目标方法执行前、后，还是异常时）。

- **注解指向的 Pointcut**：关联了**“在哪里干”**（引用刚才定义好的切入点名称）。

- **方法体内的代码**：就是具体的**“增强逻辑”**（即：干什么，比如打印日志、检查权限）。

| **@Aspect**         | 切面声明 | 声明该类是一个切面类，包含通知和切入点。                             |
| ------------------- | ---- | ------------------------------------------------ |
| **@Pointcut**       | 切入点  | 定义拦截规则（哪些类的哪些方法需要被拦截）。避免重复写 execution 表达式。       |
| **@Before**         | 前置通知 | 在目标方法**执行前**运行。常用于权限校验、参数预处理。                    |
| **@After**          | 后置通知 | 在目标方法**执行后**运行（不论成功或异常）。常用于释放资源。                 |
| **@AfterReturning** | 返回通知 | 在目标方法**正常完成后**运行。可以获取并处理方法的返回值。                  |
| **@AfterThrowing**  | 异常通知 | 在目标方法**抛出异常后**运行。用于异常监控、日志报警。                    |
| **@Around**         | 环绕通知 | **功能最全**。包围了整个方法执行。可以手动控制 proceed() 的调用，甚至替换返回值。 |
